/*
    Computational verifications for Section 3.2, when (N,r) = (4,r).
*/

QQ := Rationals();
KK<z> := CyclotomicField(8); 
PP<x0,x1,y0,y1> := PolynomialRing(KK, 4);
RR<w0,w1,w2,w3> := PolynomialRing(QQ, 4);

//----------------------
// Define some groups
GL4 := GL(4, KK);
a := Roots(Polynomial([2,0,1]), KK)[1][1];
assert a^2 eq -2; //i.e., a = sqrt(-2)

// Block diagonal matrices
g := GL4![1/a,1/(2*a),  0,0,
          2/a,-1/a,     0,0,
          
          0,0,          1/a,1/(2*a),
          0,0,          2/a,-1/a]; 

h := GL4![z^(-1),0,  0,0,
          0,z,       0,0,
          
          0,0,       z^(-1),0,
          0,0,       0,z];

// The subgroup \Lambda_1
Lambda := sub<GL4 | g,h>;
Lambda_tilde := CommutatorSubgroup(Lambda);

/*
We now define H x H where H = ker(SL_2(Z/4) - > SL_2(Z/2))
Clearly H is generated by -I, and the matrices
[ 1, 2,    [ 1, 0,
  0, 1 ]     2, 1 ]
These are T^2, and S*T^2*S where S = [0,-1,1,0] and T = [1,1,0,1]
as usual. These get mapped to the generators chosen, (the upper
block of g and h above, respectively).
*/
GL2 := GL(2, KK);
//image of S
g_2 := GL2![1/a,1/(2*a),
            2/a,-1/a];
//image of T
h_2 := GL2![z^(-1),0,
            0,z];

// The images of T^2 and S*T^2*S the representation bar(rho)
assert GL2![z^(-2), 0, 0, z^2] eq h_2^2;
assert GL2![0,1/2*z^2,2*z^2,0] eq g_2*(h_2^2)*g_2;

/*
Thus the iamge of H x H in PGL_2 is generated by the six block diagonal
matrices  given below ( the images of (-I,I), (T^2,I), (S*T^2*S, I), 
(I, -I), (I, T^2), and (I, S*T^2*S) )
*/
k11 := GL4![-1,0,  0,0,
            0,-1,  0,0,
            
            0,0,   1,0,
            0,0,   0,1];

k21 := GL4![0,1/2*z^2,  0,0,
            2*z^2,0,   0,0,
            
            0,0,    1,0,
            0,0,    0,1];

k31 := GL4![z^(-2),0,  0,0,
            0,z^2, 0,0,
            
            0,0,    1,0,
            0,0,    0,1];

k12 := GL4![1,0,  0,0,
            0,1,  0,0,
            
            0,0,  -1,0,
            0,0,  0,-1];

k22 := GL4![1,0,  0,0,
            0,1,  0,0,
            
            0,0,  0,1/2*z^2,
            0,0,  2*z^2,0];

k32 := GL4![1,0,  0,0,
            0,1,  0,0,
            
            0,0,  z^(-2),0,
            0,0,  0,z^2];

HtimesH := sub<GL4 | k11,k21,k31,k12,k22,k32>;

//----------------------
// Define some invariants

D := 16*x0^5*x1 - x0*x1^5;
c4 := 256*x0^8 + 224*x0^4*x1^4 + x1^8;
c6 := 4096*x0^12 - 8448*x0^8*x1^4 - 528*x0^4*x1^8 + x1^12;

assert IsInvariant(D, Lambda_tilde);
assert IsInvariant(c4, Lambda_tilde);
assert IsInvariant(c6, Lambda_tilde);
assert c4^3 - c6^2 eq 1728*D^4;

I11 := 4*(x0*y1 - x1*y0);
I44 := 256*x0^4*y0^4 + 16*x0^4*y1^4 + 192*x0^2*x1^2*y0^2*y1^2 + 16*x1^4*y0^4 + x1^4*y1^4;

assert IsInvariant(I11, Lambda);
assert IsInvariant(I44, Lambda);

II := [ I44^3, 
        2*I44*c4*Evaluate(c4, [y0,y1,0,0]),
        3*I11^4*I44^2,
        72*I11^2*I44*D*Evaluate(D, [y0,y1,0,0])
      ];

for inv in II do
    assert IsInvariant(inv, Lambda);
end for;

forgetful := [ II[1],
               II[2],
               ExactQuotient(II[4]^2, II[3])
             ];

for inv in forgetful do
    assert IsInvariant(inv, Lambda);
    assert IsInvariant(inv, HtimesH);
end for;

//----------------------
// Check relations
f := 192*w0^2 - 96*w0*w1 + 128*w0*w3 + 48*w0*w2 - w2^2;
c6c6 := 4*w0 - 3/2*w1 - (w3^2/w2);

assert Evaluate(f, II) eq 0;
assert Evaluate(c6c6, II) eq c6*Evaluate(c6, [y0,y1,0,0]);
